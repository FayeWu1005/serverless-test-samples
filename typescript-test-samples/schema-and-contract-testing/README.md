[![typescript: 4.5.5](https://badgen.net/badge/Built%20With/TypeScript/blue9)](https://badgen.net/badge/Built%20With/TypeScript/blue9)
[![test: unit](https://img.shields.io/badge/Test-Unit-blue)](https://img.shields.io/badge/Test-Unit-blue)

# Typescript: Schema and Contract testing for Event-Driven Architectures

---

## Contents

- [Introduction](#introduction)
- [Schema testing](#schema-testing-schema-difference)
  - [Goal](#goal)
  - [Description](#description)
  - [System under test](#system-under-test-sut)
  - [Limitations](#limitations)
- [Contract testing](#contract-testing)

  - [Goal](#goal-1)
  - [Description](#description-1)
  - [System under test](#system-under-test-sut-1)
  - [Limitations](#limitations-1)

- [Key Files in the Project](#key-files-in-this-project)
- [Run the tests](#run-the-tests)

---

## Introduction

This project contains introductory examples of TypeScript unit tests demonstrating schema and contract testing.

## Schema Testing (Schema Difference)

### Goal

Prevent changes to event schema from breaking consumer applications.

### Description

Event driven architectures decouple producers and consumers at the infrastructure layer but they are still coupled at the application layer by the event contract. Consumers rely on the event contract and schema to write their processing logic.

With a small number of producers and consumers, it might be easy to collaborate to avoid breaking changes. But as time goes on your event-driven architectures will grow and keeping on top of producer and consumer relationships can be hard. Hence it is important to automate schema validation to prevent breaking changes.

### System Under Test (SUT)

This test is integration service agnostic, as it runs against the schema published to a schema registry. Amazon EventBridge Schema Registry is one example of such a registry. It provides schemas for all events that are generated by AWS services. When you turn on schema discovery it will automatically detect and provide schemas for your custom events (OpenAPI and JSON Schemas). You can also use your own Git repository as a registry for storing schemas. In our test we will use a local “schemas” folder as a registry for simplicity.

Schema testing checks for changes that are not backward-compatible, such as removing elements, changing a field type or adding new mandatory elements. Adding optional elements is considered backward-compatible. If the updated schema is backward-compatible, the tests should be passing and the consumer application should be able to use the new version of the schema without issues.

The diagram below shows an example of running the schema validation as part of a producer’s CI/CD pipeline. A sample unit test from the "Build" step is provided in this pattern - [Schema Diff Unit Test](tests/schema-testing.test.ts).

![System Under Test (SUT)](img/schema_testing.png)

### Schema Test Limitations

Schema tests have two limitations worth mentioning. 

First, schemas are inherently ambiguous as they do not capture business requirements. They may not express that a particular combination of fields is invalid, or they may not explicitly state the dependencies between fields. For example, when you create an AWS Lambda function, the `runtime` property is mandatory for zip packaging formats, but this field is not required for container image packaging formats. The schema for the Lambda `create-function` API payload will not convey this requirement. If an event consumer makes invalid assumptions about a new version of the payload, its business logic may fail even if there are technically no breaking schema changes.

Second, unless an event consumer uses SDK/code bindings generated specifically for the version of schema in use, the code and the schema may drift apart over time and the consumer business logic may eventually fail. In these cases, the schema validation test results create a false sense of security.

Both of these limitations can be addressed with [contract testing](#contract-testing).

## Contract Testing

### System Under Test (SUT)

This test is integration service agnostic as it uses sample events generated from a schema published to a schema registry. The diagram below shows one way of implementing contract testing as part of producer’s CI/CD pipeline.

The diagram below shows an example of running the schema validation as part of a producer’s CI/CD pipeline. A sample unit test from the "Build" step is provided in this pattern - [Contract Unit Test](tests/contract-testing.test.ts).

![System Under Test (SUT)](img/contract_testing.png)

### Goal

Identify side effects of non-breaking schema changes on consumer applications.

### Description

Event driven architectures decouple producers and consumers at the infrastructure layer but they are still coupled at the application layer by the event contract. Consumers rely on the event contract and schema to write their processing logic. Contract testing uses sample events provided by producers to validate business logic on the consumer side for a stronger guarantee of preventing breaking changes. Contract tests are owned by consumers. 

Consider the following example. In a schema test, changing the format of an `address` field from a full address to a street address only and then adding new event fields like `country`, `city`, `state` and `postcode` would not produce a failure. These schema changes would be considered to be backward compatible, since the changes only add new elements. In contrast, a consumer test expecting a full address in the `address` field would fail and notify us that this change is actually not backward compatible.

There are other common strategies for implementing contract testing. One strategy is to establish test doubles. Test doubles are resources that replace production objects for testing purposes. The contract tests with test doubles run on the consumer side and expect that calls to the doubles return the same results as calls to the production application. Review the [Pact.io documentation](https://docs.pact.io/) for examples of this approach.

### Limitations

Writing tests and performing on-going maintenance requires a degree of additional effort. However once written, schema changes can be done more efficiently and with less effort to prevent and resolve breaking changes.

You may choose to be selective in deciding where to implement contract testing. Start by identifying critical applications where the cost of breaking changes is highest. Applications with greater tolerances for failure may choose to rely on schema testing only.

---

### Key Files in this Project

- [schema-testing.test.ts](tests/schema-testing.test.ts) - unit test for schema testing
- [contract-testing.test.ts](tests/contract-testing.test.ts) - unit test for contract testing
- [schemas](schemas) - versioned schemas used for schema testing
- [events](events) - sample events used for contract testing

## Run the Tests

Install the dependencies first, then run the tests:

```
 $ npm install
 $ npm run test
```

[Top](#contents)

---
